\hypertarget{class_node}{}\section{Node$<$ T $>$ Class Template Reference}
\label{class_node}\index{Node$<$ T $>$@{Node$<$ T $>$}}


{\ttfamily \#include $<$Astar.\+hpp$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_node_abb1daa11421a3174e22174bc829f3b96}{Node} (Length g=Length\+::\+M\+E\+T\+ER $\ast$0, Length h=Length\+::\+M\+E\+T\+ER $\ast$0, std\+::weak\+\_\+ptr$<$ T $>$ parent=std\+::weak\+\_\+ptr$<$ T $>$())
\item 
virtual bool \hyperlink{class_node_ab37b3f37bf857e602d19f0c16dee99db}{operator==} (const T \&n) const  =0
\item 
virtual std\+::vector$<$ T $>$ \hyperlink{class_node_a21b3fdcc109b15177bd6cb96d9202b13}{get\+\_\+available\+\_\+nodes} (std\+::shared\+\_\+ptr$<$ T $>$ \&self)=0
\item 
bool \hyperlink{class_node_a72a4ef340b3d732c7eae9ad92a2f0cf2}{operator$>$} (const T \&compare) const 
\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
const Length {\bfseries g}\hypertarget{class_node_a952609bd42c190ae78ca36c7f8aa022d}{}\label{class_node_a952609bd42c190ae78ca36c7f8aa022d}

\item 
Length {\bfseries h}\hypertarget{class_node_a3e4f962de7f9e113dcbaef80f62d7f1d}{}\label{class_node_a3e4f962de7f9e113dcbaef80f62d7f1d}

\item 
Length {\bfseries f}\hypertarget{class_node_ac989fd6403eed28850d38f65e0566d84}{}\label{class_node_ac989fd6403eed28850d38f65e0566d84}

\item 
const std\+::weak\+\_\+ptr$<$ T $>$ {\bfseries parent}\hypertarget{class_node_a25bfffd0d296e093102d92f9dcc82c4e}{}\label{class_node_a25bfffd0d296e093102d92f9dcc82c4e}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename T$>$\\*
class Node$<$ T $>$}

abstract class to be implemented by the a star implementation

represents a single node in the a star algorithm 

\subsection{Constructor \& Destructor Documentation}
\index{Node@{Node}!Node@{Node}}
\index{Node@{Node}!Node@{Node}}
\subsubsection[{\texorpdfstring{Node(\+Length g=\+Length\+::\+M\+E\+T\+E\+R $\ast$0, Length h=\+Length\+::\+M\+E\+T\+E\+R $\ast$0, std\+::weak\+\_\+ptr$<$ T $>$ parent=std\+::weak\+\_\+ptr$<$ T $>$())}{Node(Length g=Length::METER *0, Length h=Length::METER *0, std::weak_ptr< T > parent=std::weak_ptr< T >())}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ {\bf Node}$<$ T $>$\+::{\bf Node} (
\begin{DoxyParamCaption}
\item[{Length}]{g = {\ttfamily Length\+:\+:METER~$\ast$~0}, }
\item[{Length}]{h = {\ttfamily Length\+:\+:METER~$\ast$~0}, }
\item[{std\+::weak\+\_\+ptr$<$ T $>$}]{parent = {\ttfamily std\+:\+:weak\+\_\+ptr$<$T$>$()}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{class_node_abb1daa11421a3174e22174bc829f3b96}{}\label{class_node_abb1daa11421a3174e22174bc829f3b96}
creates a new node with predefined values as the variables 

\subsection{Member Function Documentation}
\index{Node@{Node}!get\+\_\+available\+\_\+nodes@{get\+\_\+available\+\_\+nodes}}
\index{get\+\_\+available\+\_\+nodes@{get\+\_\+available\+\_\+nodes}!Node@{Node}}
\subsubsection[{\texorpdfstring{get\+\_\+available\+\_\+nodes(std\+::shared\+\_\+ptr$<$ T $>$ \&self)=0}{get_available_nodes(std::shared_ptr< T > &self)=0}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ virtual std\+::vector$<$T$>$ {\bf Node}$<$ T $>$\+::get\+\_\+available\+\_\+nodes (
\begin{DoxyParamCaption}
\item[{std\+::shared\+\_\+ptr$<$ T $>$ \&}]{self}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{class_node_a21b3fdcc109b15177bd6cb96d9202b13}{}\label{class_node_a21b3fdcc109b15177bd6cb96d9202b13}
get the list of nodes that can be reached from this node

/param self this \index{Node@{Node}!operator==@{operator==}}
\index{operator==@{operator==}!Node@{Node}}
\subsubsection[{\texorpdfstring{operator==(const T \&n) const  =0}{operator==(const T &n) const  =0}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ virtual bool {\bf Node}$<$ T $>$\+::operator== (
\begin{DoxyParamCaption}
\item[{const T \&}]{n}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{class_node_ab37b3f37bf857e602d19f0c16dee99db}{}\label{class_node_ab37b3f37bf857e602d19f0c16dee99db}
checks if two nodes can be considered equal for the algorithm

/return true if the two nodes are approximately equal \index{Node@{Node}!operator$>$@{operator$>$}}
\index{operator$>$@{operator$>$}!Node@{Node}}
\subsubsection[{\texorpdfstring{operator$>$(const T \&compare) const }{operator>(const T &compare) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ bool {\bf Node}$<$ T $>$\+::operator$>$ (
\begin{DoxyParamCaption}
\item[{const T \&}]{compare}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{class_node_a72a4ef340b3d732c7eae9ad92a2f0cf2}{}\label{class_node_a72a4ef340b3d732c7eae9ad92a2f0cf2}
compares two nodes for checking which should be evaluated first 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
source/include/Astar.\+hpp\end{DoxyCompactItemize}
